import {
  Route53Client,
  CreateHostedZoneCommand,
  ChangeResourceRecordSetsCommand,
  ListResourceRecordSetsCommand,
  GetChangeCommand,
} from '@aws-sdk/client-route-53';
import isFQDN from 'validator/lib/isFQDN';
import isIP from 'validator/lib/isIP';
import Filter from 'bad-words';

import logger from '~/lib/logger.server';
import secrets from '~/lib/secrets.server';
import { buildUserBaseDomain } from '~/utils';

import type {
  CreateHostedZoneResponse,
  ChangeResourceRecordSetsResponse,
  GetChangeResponse,
  ListResourceRecordSetsResponse,
  Change,
} from '@aws-sdk/client-route-53';
import { DnsRecordType } from '@prisma/client';
import { z } from 'zod';

const filter = new Filter();

const { AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY } = secrets;
const { NODE_ENV } = process.env;

/**
 * In production, we require the root domain, hosted zone id, and AWS
 * credentials to be configured.
 */
if (NODE_ENV === 'production') {
  if (!process.env.AWS_ROUTE53_HOSTED_ZONE_ID) {
    throw new Error('AWS_ROUTE53_HOSTED_ZONE_ID environment variable is missing');
  }

  if (!process.env.ROOT_DOMAIN) {
    throw new Error('ROOT_DOMAIN environment variable is missing');
  }

  if (!AWS_ACCESS_KEY_ID) {
    throw new Error('Missing AWS_ACCESS_KEY_ID secret');
  }

  if (!AWS_SECRET_ACCESS_KEY) {
    throw new Error('Missing AWS_SECRET_ACCESS_KEY secret');
  }
} else {
  // In dev, we only need a root domain, and can fake the rest
  process.env.ROOT_DOMAIN = process.env.ROOT_DOMAIN || 'starchart.com';
}

/**
 * In production, we have to have a zone id to do anything, but in
 * dev, we create it on startup if not set.
 * @returns string - the AWS Hosted Zone ID to use
 */
async function getHostedZoneId() {
  if (!process.env.AWS_ROUTE53_HOSTED_ZONE_ID) {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('AWS_ROUTE53_HOSTED_ZONE_ID environment variable is missing');
    }

    // In development/testing, create a hosted zone if the variables are missing
    process.env.AWS_ROUTE53_HOSTED_ZONE_ID = await createHostedZone(process.env.ROOT_DOMAIN!);
    logger.debug(
      `DNS: created hosted zone ${process.env.AWS_ROUTE53_HOSTED_ZONE_ID} for ${process.env.ROOT_DOMAIN}`
    );
  }

  return process.env.AWS_ROUTE53_HOSTED_ZONE_ID;
}

const getCredentials = () => {
  if (process.env.NODE_ENV === 'production') {
    return {
      accessKeyId: AWS_ACCESS_KEY_ID,
      secretAccessKey: AWS_SECRET_ACCESS_KEY,
    };
  }

  return {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || AWS_SECRET_ACCESS_KEY,
    sessionToken: process.env.AWS_SESSION_TOKEN,
  };
};

/**
 * Allow overriding the AWS URL endpoint for Route53 in dev for moto server
 * @returns string | undefined - if we override, we provide a new URL
 */
const awsEndpoint = () => {
  return process.env.NODE_ENV === 'production' ? undefined : 'http://localhost:5053';
};

export const route53Client = new Route53Client({
  endpoint: awsEndpoint(),
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: getCredentials(),
});

export async function createHostedZone(domain: string) {
  try {
    const command = new CreateHostedZoneCommand({
      Name: domain,
      CallerReference: new Date().toString(),
    });
    const response: CreateHostedZoneResponse = await route53Client.send(command);

    if (!response.HostedZone?.Id) {
      throw new Error('Missing hosted zone ID in AWS response');
    }
    return response.HostedZone.Id.replace('/hostedzone/', '');
  } catch (error) {
    logger.warn('DNS Error in createHostedZone', { domain, error });
    throw new Error(`Error while creating hosted zone`);
  }
}

/**
 * Get a full page of records from AWS Route53. If fqdn and recordType is specified,
 * load the next page starting with that record
 *
 * https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-route-53/classes/listresourcerecordsetscommand.html
 */
export const getDnsRecordSetPage = async (
  fqdn?: string,
  // Using string as it cam be any record type not just the ones we use, also AWS sdk refers to it as string
  type?: string
): Promise<ListResourceRecordSetsResponse> => {
  try {
    const command = new ListResourceRecordSetsCommand({
      HostedZoneId: await getHostedZoneId(),
      StartRecordName: fqdn,
      StartRecordType: type,
    });

    return route53Client.send(command);
  } catch (error) {
    logger.warn('DNS Error - Error loading record page from Route53', { type, fqdn, error });

    // Rethrow to keep stack
    throw error;
  }
};

/**
 * Execute a complete changeset in Route53 generated by the reconciler
 */
export const executeChangeSet = async (Changes: Change[]) => {
  try {
    const command = new ChangeResourceRecordSetsCommand({
      ChangeBatch: { Changes },
      HostedZoneId: await getHostedZoneId(),
    });
    const response: ChangeResourceRecordSetsResponse = await route53Client.send(command);

    if (!response.ChangeInfo?.Id) {
      throw new Error(`DNS Error - missing ID in AWS ChangeInfo response`);
    }

    return response.ChangeInfo.Id;
  } catch (error) {
    logger.error('DNS Error - Failed to execute changeSet', { error });
    throw error;
  }
};

export const getChangeStatus = async (changeId: string) => {
  try {
    const command = new GetChangeCommand({
      Id: changeId,
    });
    const response: GetChangeResponse = await route53Client.send(command);

    if (!response.ChangeInfo?.Status) {
      throw new Error('DNS Error - could not get ChangeIno for requested ID from AWS response');
    }
    return response.ChangeInfo.Status;
  } catch (error) {
    logger.warn('DNS Error in getChangeStatus', { changeId, error });
    throw new Error(`Error occurred while getting change status`);
  }
};

/* Domain name rules
1. Full domain name pattern should be [subdomain].[username].rootDomain.com
2. Subdomain can contain only alphanumerical characters, '-', and '_'
3. Subdomain should not start or end with -
4. Subdomain cannot contain multiple consecutive '-' or '_'
5. Subdomain can contain uppercase in UI but it is converted to lowercase before validation */
export const isNameValid = (fqdn: string, username: string) => {
  const baseDomain = buildUserBaseDomain(username);

  /* Full domain name must end with username and root domain.
  Here it removes username and root domain,
  to validate only subdomain that user has input */
  const toRemove = `.${baseDomain}`;
  if (!fqdn.endsWith(toRemove)) {
    return false;
  }
  const subdomain = fqdn.substring(0, fqdn.length - toRemove.length);

  // Decline if subdomain has inappropriate word(s)
  if (filter.isProfane(subdomain)) {
    return false;
  }

  //It only validates subdomain name, not username and root domain
  return (
    /^(?!.*[-_]{2,})(?!^[-])[a-z0-9_-]+[a-z0-9]$/.test(subdomain) &&
    isFQDN(fqdn, {
      allow_underscores: true,
    })
  );
};

export const isValueValid = (type: DnsRecordType, value: string) => {
  if (type === 'A') {
    return isIP(value, 4);
  }

  if (type === 'AAAA') {
    return isIP(value, 6);
  }

  // CNAME can be any non-empty string. Let AWS validate it.
  return value.length >= 1;
};

export const DnsRecordSchema = z
  .object({
    subdomain: z.string().min(1),
    type: z.nativeEnum(DnsRecordType),
    value: z.string().min(1),
    ports: z.string(),
    course: z.string(),
    description: z.string(),
  })
  .refine((data) => isValueValid(data.type, data.value), {
    message: 'Record value is invalid',
    path: ['value'],
  });

export const UpdateDnsRecordSchema = z.intersection(DnsRecordSchema, z.object({ id: z.string() }));
