import {
  Route53Client,
  CreateHostedZoneCommand,
  ChangeResourceRecordSetsCommand,
  ListResourceRecordSetsCommand,
} from '@aws-sdk/client-route-53';

import logger from '~/lib/logger.server';
import secrets from '~/lib/secrets.server';

import type {
  CreateHostedZoneResponse,
  ChangeResourceRecordSetsResponse,
  ListResourceRecordSetsResponse,
  Change,
} from '@aws-sdk/client-route-53';
import { toRoute53RRType } from './route53Utils.server';

const { AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY } = secrets;
const { NODE_ENV } = process.env;

/**
 * In production, we require the root domain, hosted zone id, and AWS
 * credentials to be configured.
 */
if (NODE_ENV === 'production') {
  if (!process.env.AWS_ROUTE53_HOSTED_ZONE_ID) {
    throw new Error('AWS_ROUTE53_HOSTED_ZONE_ID environment variable is missing');
  }

  if (!process.env.ROOT_DOMAIN) {
    throw new Error('ROOT_DOMAIN environment variable is missing');
  }

  if (!AWS_ACCESS_KEY_ID) {
    throw new Error('Missing AWS_ACCESS_KEY_ID secret');
  }

  if (!AWS_SECRET_ACCESS_KEY) {
    throw new Error('Missing AWS_SECRET_ACCESS_KEY secret');
  }
} else {
  // In dev, we only need a root domain, and can fake the rest
  process.env.ROOT_DOMAIN = process.env.ROOT_DOMAIN || 'starchart.com';
}

/**
 * In production, we have to have a zone id to do anything, but in
 * dev, we create it on startup if not set.
 * @returns string - the AWS Hosted Zone ID to use
 */
async function getHostedZoneId() {
  if (!process.env.AWS_ROUTE53_HOSTED_ZONE_ID) {
    if (process.env.NODE_ENV === 'production') {
      throw new Error('AWS_ROUTE53_HOSTED_ZONE_ID environment variable is missing');
    }

    // In development/testing, create a hosted zone if the variables are missing
    process.env.AWS_ROUTE53_HOSTED_ZONE_ID = await createHostedZone(process.env.ROOT_DOMAIN!);
    logger.debug(
      `DNS: created hosted zone ${process.env.AWS_ROUTE53_HOSTED_ZONE_ID} for ${process.env.ROOT_DOMAIN}`
    );
  }

  return process.env.AWS_ROUTE53_HOSTED_ZONE_ID;
}

const getCredentials = () => {
  if (process.env.NODE_ENV === 'production') {
    return {
      accessKeyId: AWS_ACCESS_KEY_ID,
      secretAccessKey: AWS_SECRET_ACCESS_KEY,
    };
  }

  return {
    accessKeyId: process.env.AWS_ACCESS_KEY_ID || AWS_ACCESS_KEY_ID,
    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY || AWS_SECRET_ACCESS_KEY,
    sessionToken: process.env.AWS_SESSION_TOKEN,
  };
};

/**
 * Allow overriding the AWS URL endpoint for Route53 in dev for moto server
 * @returns string | undefined - if we override, we provide a new URL
 */
const awsEndpoint = () => {
  return process.env.NODE_ENV === 'production' ? undefined : 'http://localhost:5053';
};

export const route53Client = new Route53Client({
  endpoint: awsEndpoint(),
  region: process.env.AWS_REGION || 'us-east-1',
  credentials: getCredentials(),
});

export async function createHostedZone(domain: string) {
  try {
    const command = new CreateHostedZoneCommand({
      Name: domain,
      CallerReference: new Date().toString(),
    });
    const response: CreateHostedZoneResponse = await route53Client.send(command);

    if (!response.HostedZone?.Id) {
      throw new Error('Missing hosted zone ID in AWS response');
    }
    return response.HostedZone.Id.replace('/hostedzone/', '');
  } catch (error) {
    logger.warn('DNS Error in createHostedZone', { domain, error });
    throw new Error(`Error while creating hosted zone`);
  }
}

/**
 * Get a full page of records from AWS Route53. If fqdn and recordType is specified,
 * load the next page starting with that record
 *
 * https://docs.aws.amazon.com/AWSJavaScriptSDK/v3/latest/clients/client-route-53/classes/listresourcerecordsetscommand.html
 */
export const getDnsRecordSetPage = async (
  fqdn?: string,
  // Using string as it cam be any record type not just the ones we use, also AWS sdk refers to it as string
  type?: string
): Promise<ListResourceRecordSetsResponse> => {
  try {
    const command = new ListResourceRecordSetsCommand({
      HostedZoneId: await getHostedZoneId(),
      StartRecordName: fqdn,
      StartRecordType: toRoute53RRType(type),
    });

    return route53Client.send(command);
  } catch (error) {
    logger.warn('DNS Error - Error loading record page from Route53', { type, fqdn, error });

    // Rethrow to keep stack
    throw error;
  }
};

/**
 * Execute a complete changeset in Route53 generated by the reconciler
 */
export const executeChangeSet = async (Changes: Change[]) => {
  try {
    const command = new ChangeResourceRecordSetsCommand({
      ChangeBatch: { Changes },
      HostedZoneId: await getHostedZoneId(),
    });
    const response: ChangeResourceRecordSetsResponse = await route53Client.send(command);

    if (!response.ChangeInfo?.Id) {
      throw new Error(`DNS Error - missing ID in AWS ChangeInfo response`);
    }

    return response.ChangeInfo.Id;
  } catch (error) {
    logger.error('DNS Error - Failed to execute changeSet', { error });
    throw error;
  }
};
